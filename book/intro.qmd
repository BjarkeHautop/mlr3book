# Introduction {#sec-introduction}

{{< include _setup.qmd >}}

The (**M**achine **L**earning in **R**) `r mlr3` [@mlr3] package and ecosystem provide a generic, `r index("object-oriented")`, and extensible framework for `r define("regression")` (@sec-tasks), `r define("classification")` (@sec-classif), and other machine learning `r define("tasks")` (@sec-special) for the R language [@R].
This means we provide a unified interface to machine learning models ('learners' in `r mlr3` terminology) already implemented in other R packages.
With few exceptions, we do not implement any learners ourselves, although we often augment the functionality provided by the underlying learners, most commonly in the definition of hyperparameter spaces for tuning (@sec-optimization).

This unified interface provides functionality to extend and combine existing machine learning (ML) algorithms, intelligently select and tune the most appropriate technique for a given ML task, and perform large-scale comparisons that enable meta-learning.
Examples of advanced functionality include hyperparameter tuning (@sec-optimization), feature selection (@sec-feature-selection), parallelization (@sec-parallelization), and much more.

`r mlr3` has similar overall aims to `r ref_pkg("caret")` and `r ref_pkg("tidymodels")` for R, `r link("https://scikit-learn.org/", "scikit-learn")` for Python, and `r link("https://alan-turing-institute.github.io/MLJ.jl/dev/", "MLJ")` for Julia.
In general `r mlr3` is designed to provide more flexibility than other ML frameworks while still offering easy ways to use advanced functionality.
While `r ref_pkg("tidymodels")` in particular makes it very easy to perform simple ML tasks, `r mlr3` is more geared towards advanced ML.

Before reading on, if you want to practice writing any code or follow along with our examples, please install `r mlr3verse`, which includes the packages we most commonly use in this book.

```{r C0 install mlr3, eval = FALSE}
install.packages("mlr3verse")
```

## mlr3 example

The `mlr3` universe includes a wide range of tools taking you from basic ML to complex experiments.
To get started, here is an example of the most simple functionality -- training a model and making predictions.

```{r C0 egBasic}
library(mlr3)
task = tsk("penguins")
split = partition(task)
learner = lrn("classif.rpart")

learner$train(task, row_ids = split$train)
learner$model

predictions = learner$predict(task, row_ids = split$test)
predictions

predictions$score(msr("classif.acc"))
```

In this example, we trained a decision tree on a subset of the `penguins` dataset, made predictions on the rest of the data and then evaluated these with the accuracy measure. In @sec-basics we will break this down in more detail.

`r mlr3` makes training and predicting easy, but it also allows us to perform very complex operations in just a few lines of code:

```{r C0 egHard, output = FALSE}
library(mlr3verse)
library(mlr3pipelines)
library(mlr3benchmark)

tasks = tsks(c("breast_cancer", "sonar"))
tuned_rf = auto_tuner(
    tnr("grid_search", resolution = 5),
    lrn("classif.ranger", num.trees = to_tune(200, 500)),
    rsmp("holdout")
)
tuned_rf = pipeline_robustify(NULL, tuned_rf, TRUE) %>>%
    po("learner", tuned_rf)
stack_lrn = ppl(
    "stacking",
    base_learners = lrns(c("classif.rpart", "classif.kknn")),
    lrn("classif.log_reg"))
stack_lrn = pipeline_robustify(NULL, stack_lrn, TRUE) %>>%
    po("learner", stack_lrn)

learners = c(tuned_rf, stack_lrn)
bm = benchmark(benchmark_grid(tasks, learners, rsmp("holdout")))
```

```{r C0 egHardOut}
bma = bm$aggregate(msr("classif.acc"))[, c("task_id", "learner_id",
  "classif.acc")]
bma$learner_id = rep(c("RF", "Stack"), 2)
bma
```

In this (much more complex!) example we chose two tasks and two learners and used automated tuning to optimize the number of trees in the random forest learner (@sec-optimization), and an ML pipeline that imputes missing data, collapses factor levels, and creates stacked models (@sec-pipelines).
We also showed basic features like loading learners (@sec-basics) and choosing resampling strategies for benchmarking (@sec-performance).
Finally, we compared the performance of the models using the mean accuracy on the test set, and applied a statistical test to see if the learners performed significantly different (they did not!).

You will learn how to do all this and more in this book.

## From mlr to mlr3

The `r ref_pkg("mlr")`\index{mlr} package [@mlr] was first released to `r link("https://cran.r-project.org", "CRAN")` in 2013, with the core design and architecture dating back somewhat further.
Over time, the addition of many features has led to a considerably more complex design that made it harder to build, maintain, and extend than we had hoped for.
In hindsight, we saw that some design and architecture choices in `r ref_pkg("mlr")` made it difficult to support new features, in particular with respect to ML pipelines.
Furthermore, the R ecosystem and packages within it, such as `r ref_pkg("data.table")`, had undergone major changes after the initial design of `r ref_pkg("mlr")`.

It would have been difficult to integrate all of these changes into the original design of `r ref_pkg("mlr")`.
Instead, we decided to start working on a reimplementation in 2018, which resulted in the first release of `r mlr3` on CRAN in July 2019.

The new design and the integration of further and newly-developed R packages (especially `r ref_pkg("R6")`, `r ref_pkg("future")`, and `r ref_pkg("data.table")`) makes `r mlr3` much easier to use, maintain, and in many regards more efficient than its predecessor `r ref_pkg("mlr")`.
The packages in the ecosystem are less tightly coupled, making them easier to maintain and easier to develop, especially very specialized packages.

## Design principles

{{< include _optional.qmd >}}

We follow these general design principles in the `r mlr3` package and `r mlr3verse` ecosystem.

*   **Object-oriented programming (OOP)**.
We embrace `r ref_pkg("R6")` for a clean, object-oriented design, object state-changes, and reference semantics.
This means that the state of common objects (e.g. tasks (@sec-tasks) and learners (@sec-learners)) is encapsulated within the object, for example to keep track of whether a model has been trained, without the user having to worry about this.
We also use inheritance to specialize objects, e.g. all learners are derived from a common base class that provides basic functionality.
*   **Tabular data**.
Embrace `r ref_pkg("data.table")` for its top-notch computation performance as well as tabular data as a structure that can be easily processed further.
*   **Unify input and output data formats.**
This considerably simplifies the API and allows easy selection and "split-apply-combine" (aggregation) operations.
We combine `data.table` and `R6` to place references to non-atomic and compound objects in tables and make heavy use of list columns.
*   **Defensive programming and type safety**.
All user input is checked with `r ref_pkg("checkmate")` [@checkmate].
We use data.table which documents return types unlike other mechanisms popular in base R which "simplify" the result unpredictably (e.g., `sapply()` or the `drop` argument for indexing data.frames).
And we have extensive unit tests!
*   **Light on dependencies**.
One of the main maintenance burdens for `r ref_pkg("mlr")` was to keep up with changing learner interfaces and behavior of the many packages it depended on.
We require far fewer packages in `r mlr3`, which makes installation and maintenance easier.
We still provide the same functionality, but it is split into more packages that have fewer dependencies individually.
*   **Separation of computation and presentation**.
Most packages of the `r mlr3` ecosystem focus on processing and transforming data, applying ML algorithms, and computing results.
Our core packages do not provide visualizations because their dependencies would make installation unnecessarily complex, especially on headless servers (i.e., computers without a monitor where graphical libraries are not installed).
For the same reason, visualizations of data and results are provided in the extra package `r mlr3viz`, which avoids dependencies on `ggplot2`.

## The `mlr3` ecosystem

Throughout this book we often refer to `mlr3`, which does not refer to the single `r mlr3` base package but all the packages in our ecosystem.
The `r mlr3` *package* provides the base functionality that the rest of the ecosystem depends on for building more advanced ML tools.
@fig-mlr3verse shows the packages in the `mlr3verse` that extend `r mlr3` with capabilities for preprocessing, pipelining, visualizations, additional learners, additional task types, and more.

<!-- FIXME - NEED TO REDESIGN FOR PDF -->
```{r intro-001, echo = FALSE, fig.align='center', out.width="98%", eval=knitr::is_html_output()}
#| label: fig-mlr3verse
#| fig-cap: Overview of the `mlr3` ecosystem, the `mlr3verse`.
#| fig-alt: Diagram showing the packages of the mlr3verse and their relationship.
knitr::include_graphics("https://raw.githubusercontent.com/mlr-org/mlr3/master/man/figures/mlr3verse.svg")
```

A complete and up-to-date list of extension packages can be found at `r link("https://mlr-org.com/ecosystem.html")`.

As well as packages within the `mlr3` ecosystem, software in the `mlr3verse` also depends on the following popular and well-established packages:

*   `r ref_pkg("R6")`: The class system predominantly used in mlr3.
*   `r ref_pkg("data.table")`: High-performance extension of R's `data.frame`.
*   `r ref_pkg("digest")`: Cryptographic hash functions.
*   `r ref_pkg("uuid")`: Generation of universally unique identifiers.
*   `r ref_pkg("lgr")`: Configurable logging library.
*   `r ref_pkg("mlbench")` and `r ref_pkg("palmerpenguins")`: More ML data sets.
*   `r ref_pkg("evaluate")`: For capturing output, warnings, and exceptions (@sec-error-handling).
*   `r ref_pkg("future")` / `r ref_pkg("future.apply")` / `r ref_pkg("parallelly")`: For parallelization (@sec-parallelization).

We build on `r ref_pkg("R6")` for object orientation and `r ref_pkg("data.table")` to store and operate on tabular data.
As both are core to `mlr3` we *briefly* introduce both packages for beginners; in-depth expertise with of these packages is not necessary to work with `mlr3`.

### `data.table` for beginners {#sec-data.table}

The package `r ref_pkg("data.table")` implements the `r ref("data.table")`, which is a popular alternative to R's `data.frame()`.
We use `r ref_pkg("data.table")` because it is blazingly fast and scales well to bigger data.

As with `data.frame`, `data.table`s can be constructed with `r ref("data.table()")` or `r ref("as.data.table()")`:

```{r intro-002.table-001.table-002}
library(data.table)
# converting a matrix with as.data.table
as.data.table(matrix(runif(4), 2, 2))

# using data.table
dt = data.table(x = 1:6, y = rep(letters[1:3], each = 2))
dt
```

`data.table`s can be used much like `data.frame`s, but they provide additional functionality that makes complex operations easier.
For example, data can be summarized by groups with a `by` argument in the `[` operator:

```{r intro-004.table-003.table-004}
dt[, mean(x), by = "y"]
```

There is also extensive support for many kinds of database join operations that make it easy to combine multiple `data.table`s in different ways (@Stalder2014).
For an in-depth introduction, we recommend the data.table vignette @datatable.

### R6 for beginners {#sec-r6}

`r ref_pkg("R6")` is one of R's more recent paradigm for object-oriented programming (OOP).
It addresses shortcomings of earlier OO implementations in R, such as S3, which we used in `r ref_pkg("mlr")`.
If you have done any (class) object-oriented programming before, R6 should feel familiar.
We focus on the parts of R6 that you need to know to use `mlr3`.

`r define('Objects')` are created by calling the constructor of an `r ref("R6::R6Class")` object, specifically the initialization method `$new()`.
For example, say we have implemented a class called `Foo`, then  `foo = Foo$new(bar = 1)` would create a new object of class `Foo`, setting the `bar` argument of the constructor to the value `1`.
In practice, we implement a lot of sugar functionality (@sec-mlr3-utilities) in `mlr3` so you do not need to interact with `R6` constructors in this way if you would prefer not to.

Some `R6` objects may have mutable states that are encapsulated in their `r define('fields')`, which can be accessed through the dollar, `$`, operator.
Continuing the previous example, we can access the `bar` value in the `foo` object by using `foo$bar` or we could give it a new value, e.g. `foo$bar = 2`.
These fields are known as 'active bindings' and it is important to note that when called some computations are actually being run in the background.

In addition to fields, `r define('methods')` allow users to inspect the object's state, retrieve information, or perform an action that changes the internal state of the object.
For example, in `mlr3`, the `$train()` method of a learner changes the internal state of the learner by building and storing a model.

Fields and methods can be public or private \index{Methods!private}\index{Methods!public}\index{Fields!private}\index{Fields!public}.
The public fields and methods define the API to interact with the object.
In `mlr3`, you can safely ignore private methods unless you are looking to extend our universe by adding a new class (@sec-technical).

Finally, `R6` objects are `environments`, and as such have reference semantics.
This means that, for example, `foo2 = foo` does not create a new variable called `foo2` that is a copy of `foo`.
Instead it creates a variable called `foo2` that references `foo`, and so setting `foo$bar = 3` will also change `foo2$bar` to `3` and vice versa.
To copy an object, use the `$clone(deep = TRUE)` method, so to copy `foo`: `foo2 = foo$clone(deep = TRUE)` [`$clone()`]{.aside}\index{\$clone()}.

For a longer introduction, we recommend the `R6` vignettes found at `r link("https://r6.r-lib.org/")` , more detail can be found in `r link("https://adv-r.hadley.nz/r6.html")`.

## Essential `r mlr3` utilities {#sec-mlr3-utilities}

Finally, the following sections cover some important utilities that are essential to navigating the `mlr3verse`.

### Sugar Functions {.unnumbered .unlisted}

Most objects in `r mlr3` can be created through convenience functions called *helper functions* or *sugar functions*\index{sugar}.
They provide shortcuts for common code idioms, reducing the amount of code a user has to write.
For example `lrn("regr.rpart")` is the sugar version of `LearnerRegrRpart$new()`.
We heavily use helper functions throughout this book and give the equivalent "full form" for complete detail at the end of each chapter.
The helper functions are designed to cover the majority of use-covers for most users, knowledge about the full `R6` backend is most commonly required for custom objects or extensions.

### Dictionaries {.unnumbered .unlisted}

`r mlr3` uses dictionaries to store objects like learners or tasks.
Much like paper dictionaries associate words with their definitions, our dictionaries associate keys (i.e., identifiers) with objects (for example `R6` objects).
Values in dictionaries are often accessed through sugar functions that retrieve objects from the relevant dictionary, for example `lrn("regr.rpart")` is a wrapper around `mlr_learners$get("regr.rpart")` and is thus a simpler way to load a decision tree learner from the `r ref("mlr_learners")`.
We use dictionaries to group large collections of relevant objects so they can be listed and retrieved easily.
For example, you can see an overview of available learners (that are in loaded packages)and their properties  with `as.data.table(mlr_learners)`.

### mlr3viz {.unnumbered .unlisted}

`r mlr3viz` includes all plotting functionality in `mlr3` by using `r ref_pkg("ggplot2")` under the hood.
We use `r ref("ggplot2::theme_minimal()")` in all our plots to unify our aesthetic, but as with all `ggplot` outputs, users can fully customize this.

`r mlr3viz` extends `fortify` and `autoplot` for use with common `r mlr3` outputs including `r ref("Prediction")`, `r ref("Learner")`, and `r ref("BenchmarkResult")` objects (which we will introduce and cover in the next chapters).
We will cover major plot types throughout the book but the best way to learn about `r mlr3viz` is through experimentation, load the package and see what happens when you run `autoplot` on an `mlr3` object
Plot types are documented in the respective manual page that can be accessed through `?autoplot.X`, for example, the documentation of plots for regression tasks can be found by running `?autoplot.TaskRegr`.
